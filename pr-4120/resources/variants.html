

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Build variants &mdash; conda-build 3.20.5+18.g7508fed.dirty documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/conda-logo.png"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Conda-build CLI reference" href="commands/index.html" />
    <link rel="prev" title="Using shared libraries" href="use-shared-libraries.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> conda-build
          

          
          </a>

          
            
            
              <div class="version">
                3.20.5+18.g7508fed.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install-conda-build.html">Installing and updating conda-build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/index.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-guide/index.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Resources</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="build-scripts.html">Build scripts (build.sh, bld.bat)</a></li>
<li class="toctree-l2"><a class="reference internal" href="compiler-tools.html">Anaconda compiler tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="define-metadata.html">Defining metadata (meta.yaml)</a></li>
<li class="toctree-l2"><a class="reference internal" href="link-scripts.html">Adding pre-link, post-link, and pre-unlink scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="activate-scripts.html">Activate scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="make-relocatable.html">Making packages relocatable</a></li>
<li class="toctree-l2"><a class="reference internal" href="package-spec.html">Conda package specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="use-shared-libraries.html">Using shared libraries</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Build variants</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-pinning-examples">General pinning examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transition-guide">Transition guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-conda-build-variant-config-files">Creating conda-build variant config files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-variants-with-the-conda-build-api">Using variants with the conda-build API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#about-reproducibility">About reproducibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#special-variant-keys">Special variant keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coupling-keys">Coupling keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#avoiding-unnecessary-builds">Avoiding unnecessary builds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conda-variables-and-command-line-arguments-to-conda-build">CONDA_* variables and command line arguments to conda-build</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aggregation-of-multiple-variants">Aggregation of multiple variants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bootstrapping-pins-based-on-an-existing-environment">Bootstrapping pins based on an existing environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extended-keys">Extended keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#customizing-compatibility">Customizing compatibility</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pinning-expressions">Pinning expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pinning-at-the-variant-level">Pinning at the variant level</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pinning-at-the-recipe-level">Pinning at the recipe level</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#appending-to-recipes">Appending to recipes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partially-clobbering-recipes">Partially clobbering recipes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#differentiating-packages-built-with-different-variants">Differentiating packages built with different variants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extra-jinja2-functions">Extra Jinja2 functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#referencing-subpackages">Referencing subpackages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiler-packages">Compiler packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiler-versions">Compiler versions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cross-compiling">Cross-compiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#self-consistent-package-ecosystems">Self-consistent package ecosystems</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="commands/index.html">Conda-build CLI reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="add-win-start-menu-items.html">Adding Windows Start menu items</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html">Writing style guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial-template.html">Tutorial template</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">Release notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">conda-build</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Resources</a> &raquo;</li>
        
      <li>Build variants</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="build-variants">
<h1>Build variants<a class="headerlink" href="#build-variants" title="Permalink to this headline">Â¶</a></h1>
<p>The nature of binary compatibility (and incompatibility) means that we
sometimes need to build binary packages (and any package containing binaries)
with several variants to support different usage environments. For
example, using NumPy's C API means that a package must be used with the same
version of NumPy at runtime that was used at build time.</p>
<p>There has been limited support for this for a long time. Including Python in
both build and run requirements resulted in a package with Python pinned to the
version of Python used at build time, and a corresponding addition to the
filename such as &quot;py27&quot;. Similar support existed for NumPy with the addition of
an <code class="docutils literal notranslate"><span class="pre">x.x</span></code> pin in the recipe after <a class="reference external" href="https://github.com/conda/conda-build/pull/573">Conda-build PR
573</a> was merged. Before
conda-build version 3.0, there were also many longstanding proposals for general
support (<a class="reference external" href="https://github.com/conda/conda-build/issues/1142">Conda-build issue
1142</a>).</p>
<p>As of conda-build 3.0, a new configuration scheme has been added, dubbed
&quot;variants.&quot; Conceptually, this decouples pinning values from recipes, replacing
them with Jinja2 template variables. It adds support for the notion of
&quot;compatible&quot; pinnings to be integrated with ABI compatibility databases, such as
<a class="reference external" href="https://abi-laboratory.pro/">ABI Laboratory</a>. Note that the concept of
&quot;compatible&quot; pinnings is currently still under heavy development.</p>
<p>Variant input is ultimately a dictionary. These dictionaries are mostly very
flat. Keys are made directly available in Jinja2 templates. As a result, keys
in the dictionary (and in files read into dictionaries) must be valid jinja2
variable names (no <code class="docutils literal notranslate"><span class="pre">-</span></code> characters allowed). This example builds Python 2.7
and 3.5 packages in one build command:</p>
<p>conda_build_config.yaml like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">python</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">2.7</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.5</span>
</pre></div>
</div>
<p>meta.yaml contents like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">compiled-code</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python {{ python }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
</pre></div>
</div>
<p>The command to build recipes is unchanged relative to earlier conda-build
versions. For example, with our shell in the same folder as meta.yaml and
conda_build_config.yaml, we just call the <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">build</span> <span class="pre">.</span></code> command.</p>
<div class="section" id="general-pinning-examples">
<h2>General pinning examples<a class="headerlink" href="#general-pinning-examples" title="Permalink to this headline">Â¶</a></h2>
<p>There are a few characteristic use cases for pinning.  Please consider this a
map for the content below.</p>
<ol class="arabic">
<li><p class="first">Shared library providing a binary interface. All uses of this library use
the binary interface. It is convenient to apply the same pin to all of your
builds. Example: boost</p>
<p>conda_build_config.yaml in your HOME folder:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">boost</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">1.61</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">1.63</span>
<span class="nt">pin_run_as_build</span><span class="p">:</span>
  <span class="nt">boost</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">x.x</span>
</pre></div>
</div>
<p>meta.yaml:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">compiled-code</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">boost  {{ boost }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">boost</span>
</pre></div>
</div>
<p>This example demonstrates several features:</p>
<ul class="simple">
<li>User-wide configuration with a specifically named config file
(conda_build_config.yaml in your home folder). More options below in
<a class="reference internal" href="#creating-conda-build-variant-config-files">Creating conda-build variant config files</a>.</li>
<li>Building against multiple versions of a single library (set versions
installed at build time).</li>
<li>Pinning runtime requirements to the version used at build time. More
information below at <a class="reference internal" href="#pinning-at-the-variant-level">Pinning at the variant level</a>.</li>
<li>Specify granularity of pinning. <code class="docutils literal notranslate"><span class="pre">x.x</span></code> pins major and minor version. More
information at <a class="reference internal" href="#id1">Pinning expressions</a>.</li>
</ul>
</li>
<li><p class="first">Python package with externally accessible binary component. Not all uses of
this library use the binary interface (some only use pure Python). Example:
NumPy.</p>
<p>conda_build_config.yaml in your recipe folder (alongside meta.yaml):</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">numpy</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">1.11</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">1.12</span>
</pre></div>
</div>
<p>meta.yaml:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">numpy_using_pythonAPI_thing</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
</pre></div>
</div>
<p>This example demonstrates a particular feature: reduction of builds when pins
are unnecessary. Since the example recipe above only requires the Python API
to NumPy, we will only build the package once and the version of NumPy will
not be pinned at runtime to match the compile-time version.  There's more
information at <a class="reference internal" href="#avoiding-unnecessary-builds">Avoiding unnecessary builds</a>.</p>
<p>For a different package that makes use of the NumPy C API, we will need to
actually pin NumPy in this recipe (and only in this recipe, so that other
recipes don't unnecessarily build lots of variants).  To pin NumPy, you can
use the variant key directly in meta.yaml:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">numpy_using_cAPI_thing</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy  {{ numpy }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy  {{ numpy }}</span>
</pre></div>
</div>
<p>For legacy compatibility, Python is pinned implicitly without specifying
<code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">python</span> <span class="pre">}}</span></code> in your recipe. This is generally intractable to extend to
all package names, so in general, try to get in the habit of always using
the Jinja2 variable substitution for pinning using versions from your
conda_build_config.yaml file.</p>
<p>There are also more flexible ways to pin using the <a class="reference internal" href="#id1">Pinning expressions</a>.
See <a class="reference internal" href="#pinning-at-the-recipe-level">Pinning at the recipe level</a> for examples.</p>
</li>
<li><p class="first">One recipe splits into multiple packages, and package dependencies need to be
dynamically pinned among one another. Example:
GCC/libgcc/libstdc++/gfortran/etc.</p>
<p>The dynamic pinning is the tricky part. Conda-build provides new ways to
refer to other subpackages within a single recipe.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">dynamic_supackage</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;my_awesome_subpackage&#39;)</span> <span class="p p-Indicator">}}</span>

<span class="nt">outputs</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">my_awesome_subpackage</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">2.0</span>
</pre></div>
</div>
<p>By referring to subpackages this way, you don't need to worry about what the
end version of <code class="docutils literal notranslate"><span class="pre">my_awesome_subpackage</span></code> will be. Update it independently and
just let conda-build figure it out and keep things consistent. There's more
information below in the <a class="reference internal" href="#id3">Referencing subpackages</a> section.</p>
</li>
</ol>
</div>
<div class="section" id="transition-guide">
<h2>Transition guide<a class="headerlink" href="#transition-guide" title="Permalink to this headline">Â¶</a></h2>
<p>Let's say we have a set of recipes that currently builds a C library, as well as
Python and R bindings to that C library. xgboost, a recent machine learning
library, is one such example. Under conda-build 2.0 and earlier, you needed to
have 3 recipes - 1 for each component. Let's go over some simplified
<code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> files. First, the C library:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">libxgboost</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>
</pre></div>
</div>
<p>Next, the Python bindings:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">py-xgboost</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">libxgboost</span>  <span class="c1"># you probably want to pin the version here, but there&#39;s no dynamic way to do it</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">libxgboost</span>  <span class="c1"># you probably want to pin the version here, but there&#39;s no dynamic way to do it</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
</pre></div>
</div>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">r-xgboost</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">libxgboost</span>  <span class="c1"># you probably want to pin the version here, but there&#39;s no dynamic way to do it</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">r-base</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">libxgboost</span>  <span class="c1"># you probably want to pin the version here, but there&#39;s no dynamic way to do it</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">r-base</span>
</pre></div>
</div>
<p>To build these, you'd need several conda-build commands, or a tool like
conda-build-all to build out the various Python versions. With conda-build 3.0
and split packages from conda-build 2.1, we can simplify this to one coherent
recipe that also includes the matrix of all desired Python and R builds.</p>
<p>First, the <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> file:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">xgboost</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">outputs</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">libxgboost</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">py-xgboost</span>
      <span class="nt">requirements</span><span class="p">:</span>
          <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;libxgboost&#39;</span><span class="p p-Indicator">,</span> <span class="nv">exact=True)</span> <span class="p p-Indicator">}}</span>
          <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python  {{ python }}</span>

    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">r-xgboost</span>
      <span class="nt">requirements</span><span class="p">:</span>
          <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;libxgboost&#39;</span><span class="p p-Indicator">,</span> <span class="nv">exact=True)</span> <span class="p p-Indicator">}}</span>
          <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">r-base  {{ r_base }}</span>
</pre></div>
</div>
<p>Next, the <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> file, specifying our build matrix:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">python</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">2.7</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.5</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.6</span>
<span class="nt">r_base</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.3.2</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.4.0</span>
</pre></div>
</div>
<p>With this updated method, you get a complete build matrix: 6 builds total. One
libxgboost library, 3 Python versions, and 2 R versions. Additionally, the
Python and R packages will have exact pins to the libxgboost package that was
built by this recipe.</p>
</div>
<div class="section" id="creating-conda-build-variant-config-files">
<span id="conda-build-variant-config-files"></span><h2>Creating conda-build variant config files<a class="headerlink" href="#creating-conda-build-variant-config-files" title="Permalink to this headline">Â¶</a></h2>
<p>Variant input files are yaml files. Search order for these files is the following:</p>
<ol class="arabic simple">
<li>A file named <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> in the user's HOME folder (or an arbitrarily
named file specified as the value for the <code class="docutils literal notranslate"><span class="pre">conda_build/config_file</span></code> key in your
.condarc file).</li>
<li>A file named <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> in the current working directory.</li>
<li>A file named <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> in the same folder as <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>
with your recipe.</li>
<li>Any additional files specified on the command line with the
<code class="docutils literal notranslate"><span class="pre">--variant-config-files</span></code> or <code class="docutils literal notranslate"><span class="pre">-m</span></code> command line flags, which can be passed
multiple times for multiple files. The <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">build</span></code> and <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">render</span></code>
commands accept these arguments.</li>
</ol>
<p>Values in files found later in this search order will overwrite and replace the
values from earlier files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The key <code class="docutils literal notranslate"><span class="pre">conda_build/config_file</span></code> is a nested value:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda_build</span><span class="p">:</span>
  <span class="n">config_file</span><span class="p">:</span> <span class="n">some</span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">file</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-variants-with-the-conda-build-api">
<h2>Using variants with the conda-build API<a class="headerlink" href="#using-variants-with-the-conda-build-api" title="Permalink to this headline">Â¶</a></h2>
<p>Ultimately, a variant is just a dictionary. This dictionary is provided directly
to Jinja2 and you can use any declared key from your variant configuration in
your Jinja2 templates. There are two ways that you can feed this information
into the API:</p>
<ol class="arabic simple">
<li>Pass the <code class="docutils literal notranslate"><span class="pre">variants</span></code> keyword argument to API functions. Currently, the
<code class="docutils literal notranslate"><span class="pre">build</span></code>, <code class="docutils literal notranslate"><span class="pre">render</span></code>, <code class="docutils literal notranslate"><span class="pre">get_output_file_path</span></code>, and <code class="docutils literal notranslate"><span class="pre">check</span></code> functions
accept this argument. <code class="docutils literal notranslate"><span class="pre">variants</span></code> should be a dictionary where each value
is a list of versions to iterate over. These are aggregated as detailed in
the <a class="reference internal" href="#aggregation-of-multiple-variants">Aggregation of multiple variants</a> section below.</li>
<li>Set the <code class="docutils literal notranslate"><span class="pre">variant</span></code> member of a Config object. This is just a dictionary. The
values for fields should be strings or lists of strings, except &quot;extended
keys&quot;, which are documented in the <a class="reference internal" href="#extended-keys">Extended keys</a> section below.</li>
</ol>
<p>Again, with <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> contents like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">compiled-code</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python {{ python }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python {{ python }}</span>
</pre></div>
</div>
<p>You could supply a variant to build this recipe like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2.7&#39;</span><span class="p">,</span> <span class="s1">&#39;3.5&#39;</span><span class="p">]}</span>
<span class="n">api</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">path_to_recipe</span><span class="p">,</span> <span class="n">variants</span><span class="o">=</span><span class="n">variants</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that these Jinja2 variable substitutions are not limited to version
numbers. You can use them anywhere, for any string value. For example, to build
against different MPI implementations:</p>
<p>With <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> contents like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">compiled-code</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">mpi</span> <span class="p p-Indicator">}}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">mpi</span> <span class="p p-Indicator">}}</span>
</pre></div>
</div>
<p>You could supply a variant to build this recipe like this (<code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code>):</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">mpi</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">openmpi</span>  <span class="c1"># version spec here is totally valid, and will apply in the recipe</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">mpich</span>  <span class="c1"># version spec here is totally valid, and will apply in the recipe</span>
</pre></div>
</div>
<p>Selectors are valid in <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code>, so you can have one
<code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> for multiple platforms:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">mpi</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">openmpi</span>  <span class="c1"># [osx]</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">mpich</span>    <span class="c1"># [linux]</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">msmpi</span>    <span class="c1"># [win]</span>
</pre></div>
</div>
<p>Jinja is not allowed in <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code>, though. It is the source of
information to feed into other Jinja templates, and the buck has to stop
somewhere.</p>
</div>
<div class="section" id="about-reproducibility">
<h2>About reproducibility<a class="headerlink" href="#about-reproducibility" title="Permalink to this headline">Â¶</a></h2>
<p>A critical part of any build system is ensuring that you can reproduce the same
output at some future point in time. This is often essential for troubleshooting
bugs. For example, if a package contains only binaries, it is helpful to
understand what source code created those binaries, and thus what bugs might be
present.</p>
<p>Since conda-build 2.0, conda-build has recorded its rendered <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> files
into the <code class="docutils literal notranslate"><span class="pre">info/recipe</span></code> folder of each package it builds. Conda-build 3.0 is no
different in this regard, but the <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> that is recorded is a frozen set of
the variables that make up the variant for that build.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Package builders may disable including the recipe with the
<code class="docutils literal notranslate"><span class="pre">build/include_recipe</span></code> key in <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>. If the recipe is omitted from the
package, then the package is not reproducible without the source recipe.</p>
</div>
</div>
<div class="section" id="special-variant-keys">
<h2>Special variant keys<a class="headerlink" href="#special-variant-keys" title="Permalink to this headline">Â¶</a></h2>
<p>There are some special keys that behave differently and can be more nested:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">zip_keys</span></code>: a list of strings or a list of lists of strings. Strings are
keys in variant. These couple groups of keys, so that particular keys are
paired, rather than forming a matrix. This is useful, for example, to couple
vc version to Python version on Windows. More info below in the <a class="reference internal" href="#coupling-keys">Coupling
keys</a> section.</li>
<li><code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code>: should be a dictionary. Keys are package names. Values
are &quot;pinning expressions&quot; - explained in more detail in <a class="reference internal" href="#customizing-compatibility">Customizing
compatibility</a>. This is a generalization of the <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">x.x</span></code> spec, so that
you can pin your packages dynamically based on the versions used at build
time.</li>
<li><code class="docutils literal notranslate"><span class="pre">extend_keys</span></code>: specifies keys that should be aggregated, and not replaced,
by later variants. These are detailed below in the <a class="reference internal" href="#extended-keys">Extended keys</a>
section.</li>
<li><code class="docutils literal notranslate"><span class="pre">ignore_version</span></code>: list of package names whose versions should be excluded
from <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>'s requirements/build when computing hash. Described further in
<a class="reference internal" href="#avoiding-unnecessary-builds">Avoiding unnecessary builds</a>.</li>
</ul>
</div>
<div class="section" id="coupling-keys">
<h2>Coupling keys<a class="headerlink" href="#coupling-keys" title="Permalink to this headline">Â¶</a></h2>
<p>Sometimes particular versions need to be tied to other versions. For example, on
Windows, we generally follow the upstream Python.org association of Visual
Studio compiler version with Python version. Python 2.7 is always compiled with
Visual Studio 2008 (also known as MSVC 9). We don't want a
<code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> like the following to create a matrix of Python/MSVC
versions:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">python</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">2.7</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.5</span>
<span class="nt">vc</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">9</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">14</span>
</pre></div>
</div>
<p>Instead, we want 2.7 to be associated with 9, and 3.5 to be associated with 14.
The <code class="docutils literal notranslate"><span class="pre">zip_keys</span></code> key in <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> is the way to achieve this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">python</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">2.7</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.5</span>
<span class="nt">vc</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">9</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">14</span>
<span class="nt">zip_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">vc</span>
</pre></div>
</div>
<p>You can also have nested lists to achieve multiple groups of <code class="docutils literal notranslate"><span class="pre">zip_keys</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">zip_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">vc</span>
  <span class="p p-Indicator">-</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">blas</span>
</pre></div>
</div>
<p>The rules for <code class="docutils literal notranslate"><span class="pre">zip_keys</span></code> are:</p>
<ol class="arabic">
<li><p class="first">Every list in a group must be the same length. This is because without
equal length, there is no way to associate earlier elements from the
shorter list with later elements in the longer list. For example, this is
invalid, and will raise an error:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">python</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">2.7</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">3.5</span>
<span class="nt">vc</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">9</span>
<span class="nt">zip_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">vc</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">zip_keys</span></code> must be either a list of strings, or a list of lists of
strings. You can't mix them. For example, this is an error:</p>
<blockquote>
<div><div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">zip_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">python</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">vc</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">blas</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<p>Rule #1 raises an interesting use case: How does one combine CLI flags
like --python with <code class="docutils literal notranslate"><span class="pre">zip_keys</span></code>? Such a CLI flag will change the variant so that
it has only a single entry, but it will not change the <code class="docutils literal notranslate"><span class="pre">vc</span></code> entry in the
variant configuration. We'll end up with mismatched list lengths, and an error.
To overcome this, you should instead write a very simple YAML file with
all involved keys. Let's call it <code class="docutils literal notranslate"><span class="pre">python27.yaml</span></code>, to reflect its intent:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">python</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">2.7</span>
<span class="nt">vc</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">9</span>
</pre></div>
</div>
<p>Provide this file as a command-line argument:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>conda build recipe -m python27.yaml
</pre></div>
</div>
<p>You can also specify variants in JSON notation from the CLI as detailed in the
<a class="reference internal" href="#cli-vars"><span class="std std-ref">CONDA_* variables and command line arguments to conda-build</span></a> section. For example:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>conda build recipe --variants <span class="s2">&quot;{&#39;python&#39;: [&#39;2.7&#39;, &#39;3.5&#39;], &#39;vc&#39;: [&#39;9&#39;, &#39;14&#39;]}&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="avoiding-unnecessary-builds">
<h2>Avoiding unnecessary builds<a class="headerlink" href="#avoiding-unnecessary-builds" title="Permalink to this headline">Â¶</a></h2>
<p>To avoid building variants of packages where pinning does not require having
different builds, you can use the <code class="docutils literal notranslate"><span class="pre">ignore_version</span></code> key in your variant. Then
all variants are evaluated, but if any hashes are the same, then they are
considered duplicates, and are deduplicated. By omitting some packages from the
build dependencies, we can avoid creating unnecessarily specific hashes and
allow this deduplication.</p>
<p>For example, let's consider a package that uses NumPy in both run and build
requirements, and a variant that includes 2 NumPy versions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1.10&#39;</span><span class="p">,</span> <span class="s1">&#39;1.11&#39;</span><span class="p">],</span> <span class="s1">&#39;ignore_version&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;numpy&#39;</span><span class="p">]}]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy {{ numpy }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
</pre></div>
</div>
<p>Here, the variant says that we'll have two builds - one for each NumPy version.
However, since this recipe does not pin NumPy's run requirement (because it
doesn't utilize NumPy's C API), it is unnecessary to build it against both NumPy
1.10 and 1.11.</p>
<p>The rendered form of this recipe, with conda-build ignoring NumPy's value in the
recipe, is going to be just one build that looks like:</p>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ignore_version</span></code> is an empty list by default. The actual build performed is
probably done with the last 'numpy' list element in the variant, but that's
an implementation detail that you should not depend on. The order is
considered unspecified behavior because the output should be independent of the
input versions.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the output is not independent of input versions, don't use
this key</p>
</div>
<p>Any pinning done in the run requirements will affect the hash, and thus builds
will be done for each variant in the matrix. Any package that sometimes is used
for its compiled interface and sometimes used for only its Python interface may
benefit from careful use of <code class="docutils literal notranslate"><span class="pre">ignore_version</span></code> in the latter case.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code> is kind of the opposite of <code class="docutils literal notranslate"><span class="pre">ignore_version</span></code>. Where
they conflict, <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code> takes priority.</p>
</div>
</div>
<div class="section" id="conda-variables-and-command-line-arguments-to-conda-build">
<span id="cli-vars"></span><h2>CONDA_* variables and command line arguments to conda-build<a class="headerlink" href="#conda-variables-and-command-line-arguments-to-conda-build" title="Permalink to this headline">Â¶</a></h2>
<p>To ensure consistency with existing users of conda-build, environment variables
such as CONDA_PY behave as they always have, and they overwrite all variants set
in files or passed to the API.</p>
<p>The full list of respected environment variables are:</p>
<ul class="simple">
<li>CONDA_PY</li>
<li>CONDA_NPY</li>
<li>CONDA_R</li>
<li>CONDA_PERL</li>
<li>CONDA_LUA</li>
</ul>
<p>CLI flags are also still available. These are sticking around for their
usefulness in one-off jobs.</p>
<ul class="simple">
<li>--python</li>
<li>--numpy</li>
<li>--R</li>
<li>--perl</li>
<li>--lua</li>
</ul>
<p>In addition to these traditional options, there's one new flag to specify
variants: <code class="docutils literal notranslate"><span class="pre">--variants</span></code>. This flag accepts a string of JSON-formatted text. For
example:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>conda build recipe --variants <span class="s2">&quot;{python: [2.7, 3.5], vc: [9, 14]}&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregation-of-multiple-variants">
<h2>Aggregation of multiple variants<a class="headerlink" href="#aggregation-of-multiple-variants" title="Permalink to this headline">Â¶</a></h2>
<p>The matrix of all variants is first consolidated from several dicts of lists
into a single dict of lists, and then transformed in a list of dicts (using the
Cartesian product of lists), where each value is a single string from the list
of potential values.</p>
<p>For example, general input for <code class="docutils literal notranslate"><span class="pre">variants</span></code> could be something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2.7&#39;</span><span class="p">,</span> <span class="s1">&#39;3.5&#39;</span><span class="p">],</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1.10&#39;</span><span class="p">,</span> <span class="s1">&#39;1.11&#39;</span><span class="p">]}</span>
<span class="c1"># values can be strings or lists.  Strings are converted to one-element lists internally.</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3.4&#39;</span><span class="p">,</span> <span class="s1">&#39;3.5&#39;</span><span class="p">],</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>Here, let's say <code class="docutils literal notranslate"><span class="pre">b</span></code> is found after <code class="docutils literal notranslate"><span class="pre">a</span></code>, and thus has priority over <code class="docutils literal notranslate"><span class="pre">a</span></code>. Merging these
2 variants yields:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">merged</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3.4&#39;</span><span class="p">,</span> <span class="s1">&#39;3.5&#39;</span><span class="p">],</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1.11&#39;</span><span class="p">]}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">b</span></code>'s values for <code class="docutils literal notranslate"><span class="pre">python</span></code> have overwritten <code class="docutils literal notranslate"><span class="pre">a</span></code>'s. From here, we compute the
Cartesian product of all input variables. The end result is a collection of
dicts, each with a string for each value. Output would be something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;3.4&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;3.5&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p>conda-build would loop over these variants where appropriate, such as when
building, outputting package output names, and so on.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">numpy</span></code> had had two values instead of one, we'd end up with <em>four</em> output
variants: 2 variants for <code class="docutils literal notranslate"><span class="pre">python</span></code>, <em>times</em> 2 variants for <code class="docutils literal notranslate"><span class="pre">numpy</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;3.4&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;3.5&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;3.4&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.10&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;3.5&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.10&#39;</span><span class="p">}]</span>
</pre></div>
</div>
</div>
<div class="section" id="bootstrapping-pins-based-on-an-existing-environment">
<h2>Bootstrapping pins based on an existing environment<a class="headerlink" href="#bootstrapping-pins-based-on-an-existing-environment" title="Permalink to this headline">Â¶</a></h2>
<p>To establish your initial variant, you may point to an existing conda
environment. Conda-build will examine the contents of that environment and pin
to the exact requirements that make up that environment.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>conda build --bootstrap name_of_env
</pre></div>
</div>
<p>You may specify either environment name or filesystem path to the environment.
Note that specifying environment name does mean depending on conda's
environment lookup.</p>
</div>
<div class="section" id="extended-keys">
<h2>Extended keys<a class="headerlink" href="#extended-keys" title="Permalink to this headline">Â¶</a></h2>
<p>These are not looped over to establish the build matrix. Rather, they are
aggregated from all input variants, and each derived variant shares the whole
set. These are used internally for tracking which requirements should be pinned,
for example, with the <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code> key. You can add your own extended
keys by passing in values for the <code class="docutils literal notranslate"><span class="pre">extend_keys</span></code> key for any variant.</p>
<p>For example, if you wanted to collect some aggregate trait from multiple
<code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> files, you could do something like this:</p>
<p><code class="docutils literal notranslate"><span class="pre">HOME/conda_build_config.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">some_trait</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">dog</span>
<span class="nt">extend_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">some_trait</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">recipe/conda_build_config.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">some_trait</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">pony</span>
<span class="nt">extend_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">some_trait</span>
</pre></div>
</div>
<p>Note that <em>both</em> of the <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> files need to list the trait as
an <code class="docutils literal notranslate"><span class="pre">extend_keys</span></code> entry.  If you list it in only one of them, an error will be
raised to avoid confusion with one <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> file that would add
entries to the build matrix, and another which would not. For example, this
should raise an error:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">some_trait</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">dog</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">recipe/conda_build_config.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">some_trait</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">pony</span>
<span class="nt">extend_keys</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">some_trait</span>
</pre></div>
</div>
<p>When our two proper YAML config files are combined, ordinarily the recipe-local
variant would overwrite the user-wide variant, yielding <code class="docutils literal notranslate"><span class="pre">{'some_trait':</span>
<span class="pre">'pony'}</span></code>. However, with the <code class="docutils literal notranslate"><span class="pre">extend_keys</span></code> entry, we end up with what we've always
wanted: a dog <em>and</em> pony show: <code class="docutils literal notranslate"><span class="pre">{'some_trait':</span> <span class="pre">['dog',</span> <span class="pre">'pony'])}</span></code></p>
<p>Again, this is mostly an internal implementation detail - unless you find a use for it.
Internally, it is used to aggregate the <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code> and
<code class="docutils literal notranslate"><span class="pre">ignore_version</span></code> entries from any of your <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code>
files.</p>
</div>
<div class="section" id="customizing-compatibility">
<h2>Customizing compatibility<a class="headerlink" href="#customizing-compatibility" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="pinning-expressions">
<span id="id1"></span><h3>Pinning expressions<a class="headerlink" href="#pinning-expressions" title="Permalink to this headline">Â¶</a></h3>
<p>Pinning expressions are the syntax used to specify how many parts of the version
to pin. They are by convention strings containing <code class="docutils literal notranslate"><span class="pre">x</span></code> characters separated by
<code class="docutils literal notranslate"><span class="pre">.</span></code>. The number of version parts to pin is simply the number of things that
are separated by <code class="docutils literal notranslate"><span class="pre">.</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">&quot;x.x&quot;</span></code> pins major and minor version.
<code class="docutils literal notranslate"><span class="pre">&quot;x&quot;</span></code> pins only major version.</p>
<p>Wherever pinning expressions are accepted, you can customize both lower and
upper bounds.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># produces pins like &gt;=1.11.2,&lt;1.12</span>
<span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">,</span> <span class="s1">&#39;pin_run_as_build&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;max_pin&#39;</span><span class="p">:</span> <span class="s1">&#39;x.x&#39;</span><span class="p">}}}]</span>
</pre></div>
</div>
<p>Note that the final pin may be more specific than your initial spec. Here, the
spec is 1.11, but the produced pin could be 1.11.2, the exact version of NumPy
that was used at build time.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># produces pins like &gt;=1.11,&lt;2</span>
<span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">,</span> <span class="s1">&#39;pin_run_as_build&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;min_pin&#39;</span><span class="p">:</span> <span class="s1">&#39;x.x&#39;</span><span class="p">,</span> <span class="s1">&#39;max_pin&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">}}}]</span>
</pre></div>
</div>
</div>
<div class="section" id="pinning-at-the-variant-level">
<h3>Pinning at the variant level<a class="headerlink" href="#pinning-at-the-variant-level" title="Permalink to this headline">Â¶</a></h3>
<p>Some packages, such as boost, <em>always</em> need to be pinned at runtime to the
version that was present at build time. For these cases where the need for
pinning is consistent, pinning at the variant level is a good option.
Conda-build will automatically pin run requirements to the versions present in
the build environment when the following conditions are met:</p>
<ol class="arabic simple">
<li>The dependency is listed in the requirements/build section. It can be pinned,
but does not need to be.</li>
<li>The dependency is listed by name (no pinning) in the requirements/run section.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code> key in the variant has a value that is a dictionary,
containing a key that matches the dependency name listed in the run
requirements. The value should be a dictionary with up to 4 keys:
<code class="docutils literal notranslate"><span class="pre">min_pin</span></code>, <code class="docutils literal notranslate"><span class="pre">max_pin</span></code>, <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>, <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>. The first 2 are
pinning expressions. The latter 2 are version numbers, overriding detection
of current version.</li>
</ol>
<p>An example variant/recipe is shown here:</p>
<p><code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">boost</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.63</span>
<span class="nt">pin_run_as_build</span><span class="p">:</span>
    <span class="nt">boost</span><span class="p">:</span>
      <span class="nt">max_pin</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">x.x</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">boost {{ boost }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">boost</span>
</pre></div>
</div>
<p>The result here is that the runtime boost dependency will be pinned to
<code class="docutils literal notranslate"><span class="pre">&gt;=(current</span> <span class="pre">boost</span> <span class="pre">1.63.x</span> <span class="pre">version),&lt;1.64</span></code>.</p>
<p>More details on the <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code> function is below in the
<a class="reference internal" href="#extra-jinja2"><span class="std std-ref">Extra Jinja2 functions</span></a> section.</p>
<p>Note that there are some packages that you should not use <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code>
for. Packages that don't <em>always</em> need to be pinned should be pinned on a
per-recipe basis (described in the next section). NumPy is an interesting
example here. It actually would not make a good case for pinning at the variant
level. Because you only need this kind of pinning for recipes that use NumPy's C
API, it would actually be better not to pin NumPy with <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code>.
Pinning it is over-constraining your requirements unnecessarily when you are not
using NumPy's C API. Instead, we should customize it for each recipe that uses
NumPy. See also the <a class="reference internal" href="#avoiding-unnecessary-builds">Avoiding unnecessary builds</a> section above.</p>
</div>
<div class="section" id="pinning-at-the-recipe-level">
<h3>Pinning at the recipe level<a class="headerlink" href="#pinning-at-the-recipe-level" title="Permalink to this headline">Â¶</a></h3>
<p>Pinning at the recipe level overrides pinning at the variant level, because run
dependencies that have pinning values in <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> (even as Jinja variables) are
ignored by the logic handling <code class="docutils literal notranslate"><span class="pre">pin_run_as_build</span></code>. We expect that pinning at
the recipe level will be used when some recipe's pinning is unusually stringent
(or loose) relative to some standard pinning from the variant level.</p>
<p>By default, with the <code class="docutils literal notranslate"><span class="pre">pin_compatible('package_name')</span></code> function, conda-build pins to your
current version and less than the next major version. For projects that don't
follow the philosophy of semantic versioning, you might want to restrict things
more tightly. To do so, you can pass one of two arguments to the <code class="docutils literal notranslate"><span class="pre">pin_compatible</span></code>
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy {{ numpy }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_compatible(&#39;numpy&#39;</span><span class="p p-Indicator">,</span> <span class="nv">max_pin=&#39;x.x&#39;)</span> <span class="p p-Indicator">}}</span>
</pre></div>
</div>
<p>This would yield a pinning of <code class="docutils literal notranslate"><span class="pre">&gt;=1.11.2,&lt;1.12</span></code>.</p>
<p>The syntax for the <code class="docutils literal notranslate"><span class="pre">min_pin</span></code> and <code class="docutils literal notranslate"><span class="pre">max_pin</span></code> is a string pinning expression.
Each can be passed independently of the other. An example of specifying both:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy {{ numpy }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_compatible(&#39;numpy&#39;</span><span class="p p-Indicator">,</span> <span class="nv">min_pin=&#39;x.x&#39;</span><span class="p p-Indicator">,</span> <span class="nv">max_pin=&#39;x.x&#39;)</span> <span class="p p-Indicator">}}</span>
</pre></div>
</div>
<p>This would yield a pinning of <code class="docutils literal notranslate"><span class="pre">&gt;=1.11,&lt;1.12</span></code>.</p>
<p>You can also pass the minimum or maximum version directly. These arguments supersede the
<code class="docutils literal notranslate"><span class="pre">min_pin</span></code> and <code class="docutils literal notranslate"><span class="pre">max_pin</span></code> arguments and are thus mutually exclusive.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;numpy&#39;</span><span class="p">:</span> <span class="s1">&#39;1.11&#39;</span><span class="p">}]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">numpy {{ numpy }}</span>
    <span class="nt">run</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_compatible(&#39;numpy&#39;</span><span class="p p-Indicator">,</span> <span class="nv">lower_bound=&#39;1.10&#39;</span><span class="p p-Indicator">,</span> <span class="nv">upper_bound=&#39;3.0&#39;)</span> <span class="p p-Indicator">}}</span>
</pre></div>
</div>
<p>This would yield a pinning of <code class="docutils literal notranslate"><span class="pre">&gt;=1.10,&lt;3.0</span></code>.</p>
</div>
</div>
<div class="section" id="appending-to-recipes">
<h2>Appending to recipes<a class="headerlink" href="#appending-to-recipes" title="Permalink to this headline">Â¶</a></h2>
<p>As of conda-build 3.0, you can add a file named <code class="docutils literal notranslate"><span class="pre">recipe_append.yaml</span></code> in the
same folder as your <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> file. This file is considered to follow the
same rules as <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>, except that selectors and Jinja2 templates are not
evaluated. Evaluation of selectors and Jinja2 templates will likely be added
in future development.</p>
<p>Any contents in <code class="docutils literal notranslate"><span class="pre">recipe_append.yaml</span></code> will add to the contents of <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>.
List values will be extended and string values will be concatenated. The
proposed use case for this is to tweak/extend central recipes, such as those
from conda-forge, with additional requirements while minimizing the actual
changes to recipe files so as to avoid merge conflicts and source code
divergence.</p>
</div>
<div class="section" id="partially-clobbering-recipes">
<h2>Partially clobbering recipes<a class="headerlink" href="#partially-clobbering-recipes" title="Permalink to this headline">Â¶</a></h2>
<p>As of conda-build 3.0, you can add a file named <code class="docutils literal notranslate"><span class="pre">recipe_clobber.yaml</span></code> in the
same folder as your <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> file. This file is considered to follow the
same rules as <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>, except that selectors and Jinja2 templates are not
evaluated. Evaluation of selectors and Jinja2 templates will likely be added
in future development.</p>
<p>Any contents in <code class="docutils literal notranslate"><span class="pre">recipe_clobber.yaml</span></code> will replace the contents of <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>.
This can be useful, for example, for replacing the source URL without copying
the rest of the recipe into a fork.</p>
</div>
<div class="section" id="differentiating-packages-built-with-different-variants">
<h2>Differentiating packages built with different variants<a class="headerlink" href="#differentiating-packages-built-with-different-variants" title="Permalink to this headline">Â¶</a></h2>
<p>With only a few things supported, we could just add things to the filename, such
as py27 for Python, or np111 for NumPy. Variants are meant to support the
general case, and in the general case this is no longer an option. Instead,
used variant keys and values are hashed using the SHA1 algorithm, and that hash is a
unique identifier. The information that went into the hash is stored with the
package in a file at <code class="docutils literal notranslate"><span class="pre">info/hash_input.json</span></code>. Packages only have a hash when
there are any &quot;used&quot; variables beyond the ones that are already accounted for in
the build string (py, np, etc). The takeaway message is that hashes will appear
when binary compatibility matters, but not when it doesn't.</p>
<p>Currently, only the first 7 characters of the hash are stored. Output package
names will keep the pyXY and npXYY, but may have added the 7-character hash.
Your package names will look like:</p>
<p><code class="docutils literal notranslate"><span class="pre">my-package-1.0-py27h3142afe_0.tar.bz2</span></code></p>
<p>As of conda-build 3.1.0, this hashing scheme has been simplified. A hash will be
added if all of these are true for any dependency:</p>
<ul class="simple">
<li>Package is an explicit dependency in build, host, or run deps.</li>
<li>Package has a matching entry in <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> which is a pin to a
specific version, not a lower bound.</li>
<li>That package is not ignored by ignore_version.</li>
</ul>
<p>OR</p>
<ul class="simple">
<li>Package uses {{ compiler() }} Jinja2 function.</li>
</ul>
<p>Since conflicts only need to be prevented within one version of a package, we
think this will be adequate. If you run into hash collisions with this limited
subspace, please file an issue on the <a class="reference external" href="https://github.com/conda/conda-build/issues">conda-build issue tracker</a>.</p>
<p>There is a CLI tool that just pretty-prints this JSON file for easy viewing:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>conda inspect hash-inputs &lt;package path&gt;
</pre></div>
</div>
<p>This produces output such as:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">{</span><span class="s1">&#39;python-3.6.4-h6538335_1&#39;</span>: <span class="o">{</span><span class="s1">&#39;files&#39;</span>: <span class="o">[]</span>,
                            <span class="s1">&#39;recipe&#39;</span>: <span class="o">{</span><span class="s1">&#39;c_compiler&#39;</span>: <span class="s1">&#39;vs2015&#39;</span>,
                                        <span class="s1">&#39;cxx_compiler&#39;</span>: <span class="s1">&#39;vs2015&#39;</span><span class="o">}}}</span>
</pre></div>
</div>
</div>
<div class="section" id="extra-jinja2-functions">
<span id="extra-jinja2"></span><h2>Extra Jinja2 functions<a class="headerlink" href="#extra-jinja2-functions" title="Permalink to this headline">Â¶</a></h2>
<p>Two especially common operations when dealing with these API and ABI
incompatibilities are ways of specifying such compatibility, and of explicitly
expressing the compiler to be used. Three new Jinja2 functions are available when
evaluating <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> templates:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">pin_compatible('package_name',</span> <span class="pre">min_pin='x.x.x.x.x.x',</span> <span class="pre">max_pin='x',</span>
<span class="pre">lower_bound=None,</span> <span class="pre">upper_bound=None)</span></code>: To be used as pin in run and/or test
requirements. Takes package name argument. Looks up compatibility of named
package installed in the build environment and writes compatible range pin
for run and/or test requirements. Defaults to a semver-based assumption:
<code class="docutils literal notranslate"><span class="pre">package_name</span> <span class="pre">&gt;=(current</span> <span class="pre">version),&lt;(next</span> <span class="pre">major</span> <span class="pre">version)</span></code>. Pass <code class="docutils literal notranslate"><span class="pre">min_pin</span></code>
or <code class="docutils literal notranslate"><span class="pre">max_pin</span></code> a <a class="reference internal" href="#id1">Pinning expressions</a> . This will be enhanced as time goes
on with information from <a class="reference external" href="https://abi-laboratory.pro/">ABI Laboratory</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">pin_subpackage('package_name',</span> <span class="pre">min_pin='x.x.x.x.x.x',</span> <span class="pre">max_pin='x',</span>
<span class="pre">exact=False)</span></code>: To be used as pin in run and/or test requirements. Takes
package name argument. Used to refer to particular versions of subpackages
built by parent recipe as dependencies elsewhere in that recipe. Can use
either pinning expressions, or exact (including build string).</li>
<li><code class="docutils literal notranslate"><span class="pre">compiler('language')</span></code>: To be used in build requirements most commonly.
Run or test as necessary. Takes language name argument. This is shorthand to
facilitate cross-compiler usage. This Jinja2 function ties together 2
variant variables, <code class="docutils literal notranslate"><span class="pre">{language}_compiler</span></code> and <code class="docutils literal notranslate"><span class="pre">target_platform</span></code>, and
outputs a single compiler package name. For example, this could be used to
compile outputs targeting x86_64 and arm in one recipe, with a variant.</li>
</ul>
<p>There are default &quot;native&quot; compilers that are used when no compiler is specified
in any variant. These are defined in <a class="reference external" href="https://github.com/conda/conda-build/blob/master/conda_build/jinja_context.py">conda-build's jinja_context.py file</a>.
Most of the time, users will not need to provide compilers in their variants -
just leave them empty and conda-build will use the defaults appropriate for
your system.</p>
</div>
<div class="section" id="referencing-subpackages">
<span id="id3"></span><h2>Referencing subpackages<a class="headerlink" href="#referencing-subpackages" title="Permalink to this headline">Â¶</a></h2>
<p>Conda-build 2.1 brought in the ability to build multiple output packages from a
single recipe. This is useful in cases where you have a big build that outputs a
lot of things at once, but those things really belong in their own packages. For
example, building GCC outputs not only GCC, but also GFortran, g++, and runtime
libraries for GCC, GFortran, and g++. Each of those should be their own package to
make things as clean as possible. Unfortunately, if there are separate recipes
to repack the different pieces from a larger, whole package it can be hard to
keep them in sync. That's where variants come in. Variants, and more
specifically the <code class="docutils literal notranslate"><span class="pre">pin_subpackage(name)</span></code> function, give you a way to refer to
the subpackage with control over how tightly the subpackage version relationship
should be in relation to other subpackages or the parent package. The following
will output 5 conda packages.</p>
<p><code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">subpackage_demo</span>
  <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
  <span class="nt">run</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;subpackage_1&#39;)</span> <span class="p p-Indicator">}}</span>
    <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;subpackage_2&#39;</span><span class="p p-Indicator">,</span> <span class="nv">max_pin=&#39;x.x&#39;)</span> <span class="p p-Indicator">}}</span>
    <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;subpackage_3&#39;</span><span class="p p-Indicator">,</span> <span class="nv">min_pin=&#39;x.x&#39;</span><span class="p p-Indicator">,</span> <span class="nv">max_pin=&#39;x.x&#39;)</span> <span class="p p-Indicator">}}</span>
    <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">pin_subpackage(&#39;subpackage_4&#39;</span><span class="p p-Indicator">,</span> <span class="nv">exact=True)</span> <span class="p p-Indicator">}}</span>


<span class="nt">outputs</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">subpackage_1</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0.0</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">subpackage_2</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">2.0.0</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">subpackage_3</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3.0.0</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">subpackage_4</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">4.0.0</span>
</pre></div>
</div>
<p>Here, the parent package will have the following different runtime dependencies:</p>
<ul class="simple">
<li>subpackage_1 &gt;=1.0.0,&lt;2 (default uses <code class="docutils literal notranslate"><span class="pre">min_pin='x.x.x.x.x.x</span></code>,
<code class="docutils literal notranslate"><span class="pre">max_pin='x'</span></code>, pins to major version with default &gt;= current version lower
bound)</li>
<li>subpackage_2 &gt;=2.0.0,&lt;2.1 (more stringent upper bound)</li>
<li>subpackage_3 &gt;=3.0,&lt;3.1 (less stringent lower bound, more stringent upper bound)</li>
<li>subpackage_4 4.0.0 h81241af (exact pinning - version plus build string)</li>
</ul>
</div>
<div class="section" id="compiler-packages">
<h2>Compiler packages<a class="headerlink" href="#compiler-packages" title="Permalink to this headline">Â¶</a></h2>
<p>On macOS and Linux, we can and do ship GCC packages. These will become even more
powerful with variants since you can specify versions of your compiler much
more explicitly and build against different versions, or with different flags
set in the compiler package's activate.d scripts. On Windows, rather than
providing the actual compilers in packages, we still use the compilers that
are installed on the system. The analogous compiler packages on Windows run
any compiler activation scripts and set compiler flags instead of actually
installing anything.</p>
<p>Over time, conda-build will require that all packages explicitly list their
compiler requirements this way. This is to both simplify conda-build and improve
the tracking of metadata associated with compilers - localize it to compiler
packages, even if those packages are doing nothing more than activating an
already-installed compiler, such as Visual Studio.</p>
<p>Note also the <code class="docutils literal notranslate"><span class="pre">run_exports</span></code> key in <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>. This is useful for compiler
recipes to impose runtime constraints based on the versions of subpackages
created by the compiler recipe. For more information, see the <a class="reference internal" href="define-metadata.html#run-exports"><span class="std std-ref">Export runtime requirements</span></a>
section of the <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> docs. Compiler packages provided by Anaconda use the
<code class="docutils literal notranslate"><span class="pre">run_exports</span></code> key extensively. For example, recipes that include the
<code class="docutils literal notranslate"><span class="pre">gcc_linux-cos5-x86_64</span></code> package as a build time dependency (either directly,
or through a <code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">compilers('c')</span> <span class="pre">}}</span></code> Jinja2 function) will automatically have a
compatible libgcc runtime dependency added.</p>
</div>
<div class="section" id="compiler-versions">
<h2>Compiler versions<a class="headerlink" href="#compiler-versions" title="Permalink to this headline">Â¶</a></h2>
<p>Usually the newest compilers are the best compilers, but in some special cases
you'll need to use older compilers.</p>
<p>For example, NVIDIA's CUDA libraries only support compilers that they have
rigorously tested. Often the latest GCC compiler is not supported for use with
CUDA. If your recipe needs to use CUDA, you'll need to use an older version of
GCC.</p>
<p>There are special keys associated with the compilers. The key name of each
special key is the compiler key name plus <code class="docutils literal notranslate"><span class="pre">_version</span></code>.</p>
<p>For example, if your compiler key is <code class="docutils literal notranslate"><span class="pre">c_compiler</span></code>, the version key associated
with it is <code class="docutils literal notranslate"><span class="pre">c_compiler_version</span></code>. If you have a recipe for Tensorflow with GPU
support, put a <code class="docutils literal notranslate"><span class="pre">conda_build_config.yaml</span></code> file alongside <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code>, with contents
like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">c_compiler_version</span><span class="p">:</span>    <span class="c1"># [linux]</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">5.4</span>              <span class="c1"># [linux]</span>
<span class="nt">cxx_compiler_version</span><span class="p">:</span>  <span class="c1"># [linux]</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">5.4</span>              <span class="c1"># [linux]</span>
</pre></div>
</div>
<p>Specify selectors so that this extra version information is not also applied to
Windows and macOS. Those platforms have totally different compilers and could
have their own versions if necessary.</p>
<p>It is not necessary to specify <code class="docutils literal notranslate"><span class="pre">c_compiler</span></code> or <code class="docutils literal notranslate"><span class="pre">cxx_compiler</span></code> because the
default value (<code class="docutils literal notranslate"><span class="pre">gcc</span></code> on Linux) will be used. It is necessary to specify both
<code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">cxx</span></code> versions, even if they are the same, because they are treated
independently.</p>
<p>By placing this file in the recipe, it will apply only to this recipe. All other
recipes will default to the latest compiler.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The version number you specify here must exist as a package in your
currently configured channels.</p>
</div>
</div>
<div class="section" id="cross-compiling">
<h2>Cross-compiling<a class="headerlink" href="#cross-compiling" title="Permalink to this headline">Â¶</a></h2>
<p>The compiler Jinja2 function is written to support cross-compilers. This depends
on setting at least 2 variant keys: <code class="docutils literal notranslate"><span class="pre">(language)_compiler</span></code> and
<code class="docutils literal notranslate"><span class="pre">target_platform</span></code>. The target platform is appended to the value of
<code class="docutils literal notranslate"><span class="pre">(language)_compiler</span></code> with the <code class="docutils literal notranslate"><span class="pre">_</span></code> character. This leads to package names
like <code class="docutils literal notranslate"><span class="pre">g++_linux-aarch64</span></code>. We recommend a convention for naming your
compiler packages as: <code class="docutils literal notranslate"><span class="pre">&lt;compiler</span> <span class="pre">name&gt;_&lt;target_platform&gt;</span></code>.</p>
<p>Using a cross-compiler in a recipe would look like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cxx_compiler&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g++&#39;</span><span class="p">],</span> <span class="s1">&#39;target_platform&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;linux-cos5-x86_64&#39;</span><span class="p">,</span> <span class="s1">&#39;linux-aarch64&#39;</span><span class="p">]}</span>
</pre></div>
</div>
<p>and a <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> file:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">compiled-code</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">compiler(&#39;cxx&#39;)</span> <span class="p p-Indicator">}}</span>
</pre></div>
</div>
<p>This assumes that you have created 2 compiler packages named
<code class="docutils literal notranslate"><span class="pre">g++_linux-cos5-x86_64</span></code> and <code class="docutils literal notranslate"><span class="pre">g++_linux-aarch64</span></code> - all conda-build
is providing you with is a way to loop over appropriately named cross-compiler
toolchains.</p>
</div>
<div class="section" id="self-consistent-package-ecosystems">
<h2>Self-consistent package ecosystems<a class="headerlink" href="#self-consistent-package-ecosystems" title="Permalink to this headline">Â¶</a></h2>
<p>The compiler function is also how you could support a non-standard Visual Studio
version, such as using VS 2015 to compile Python 2.7 and packages for Python
2.7. To accomplish this, you need to add the <code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">compiler('&lt;language&gt;')</span> <span class="pre">}}</span></code> to
each recipe that will make up the system.  Environment consistency is maintained
through dependencies - thus it is useful to have the runtime be a versioned
package with only one version being able to be installed at a time. For
example, the <code class="docutils literal notranslate"><span class="pre">vc</span></code> package, originally created by Conda-Forge, is a versioned
package (only one version can be installed at a time), and it installs the
correct runtime package. When the compiler package imposes such a runtime
dependency, then the resultant ecosystem is self-consistent.</p>
<p>Given these guidelines, consider a system of recipes using a variant like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variants</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cxx_compiler&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;vs2015&#39;</span><span class="p">]}</span>
</pre></div>
</div>
<p>The recipes include a compiler <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> like this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">vs2015</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">14.0</span>
<span class="nt">build</span><span class="p">:</span>
    <span class="nt">run_exports</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">vc 14</span>
</pre></div>
</div>
<p>They also include some compiler-using <code class="docutils literal notranslate"><span class="pre">meta.yaml</span></code> contents like this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">package</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">compiled-code</span>
    <span class="nt">version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1.0</span>

<span class="nt">requirements</span><span class="p">:</span>
    <span class="nt">build</span><span class="p">:</span>
        <span class="c1"># these are the same (and thus redundant) on windows, but different elsewhere</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">compiler(&#39;c&#39;)</span> <span class="p p-Indicator">}}</span>
        <span class="p p-Indicator">-</span> <span class="p p-Indicator">{{</span> <span class="nv">compiler(&#39;cxx&#39;)</span> <span class="p p-Indicator">}}</span>
</pre></div>
</div>
<p>These recipes will create a system of packages that are all built with the
VS 2015 compiler, and which have the vc package matched at version 14, rather
than whatever default is associated with the Python version.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="commands/index.html" class="btn btn-neutral float-right" title="Conda-build CLI reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="use-shared-libraries.html" class="btn btn-neutral float-left" title="Using shared libraries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Anaconda, Inc.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>